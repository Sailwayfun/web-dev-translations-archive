---
title: 無用的 useCallback
description: 為什麼大多數的記憶化根本毫無用處...
date: 2025-07-28
banner: /useless.jpg
tags:
  - React
  - JavaScript
  - useCallback
  - Performance
---

import Attribution from '../../components/Attribution.astro'

> 本文是 [The Useless useCallback](https://tkdodo.eu/blog/the-useless-use-callback) 的繁體中文翻譯，原文由 TkDodo 撰寫。

<Attribution name="Nik Shuliahin" url="https://unsplash.com/@tjump" />

- [#1: 記憶化的艱苦奮戰](the-uphill-battle-of-memoization)
- <b>#2: 無用的 useCallback</b>

---

我以為我已經寫了足夠多關於記憶化的文章，但最近我經常看到一種模式，讓我覺得還需要再說些什麼。所以今天，我想討論 `useCallback`，以及在某種程度上的 `useMemo`，在我認為它們完全沒有意義的情況下。

## 為什麼要記憶化？

使用 `useCallback` 創建記憶化的函式，或使用 `useMemo` 創建記憶化的值，通常只有兩個原因：

### 效能優化

有些東西很慢，而慢通常是不好的。理想情況下，我們會讓它變快，但我們不總是能做到。所以，我們可以嘗試減少執行那些慢速操作的頻率。

在 React 中，很多時候，慢的東西是子樹的重新渲染，所以如果我們認為這是「不必要的」，我們會想盡量避免它。

這就是為什麼我們有時會用 `React.memo` 包裝元件，這是一場[艱苦的戰鬥](the-uphill-battle-of-memoization)，大多數情況下不值得打，但它確實存在。

如果我們傳遞一個函式或非原始值給記憶化的元件，我們需要確保這些引用是**穩定的**。這是因為 React 使用 [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 來比較記憶化元件的 props，以檢查是否可以跳過渲染該子樹。所以如果引用不穩定，例如因為它在每次渲染時都被重新創建，我們的記憶化就會「失效」：

```tsx title=performance-optimization
function Meh() {
  return (
    <MemoizedComponent
      value={{ hello: 'world' }}
      onChange={(result) => console.log('result')}
    />
  )
}

function Okay() {
  const value = useMemo(() => ({ hello: 'world' }), [])
  const onChange = useCallback((result) => console.log(result), [])

  return <MemoizedComponent value={value} onChange={onChange} />
}
```

是的，有時候 `useMemo` 內部的計算本身就很慢，我們記憶化是為了避免那些重複計算。這些 `useMemo` 的使用完全沒問題，但我不認為它們是主要的使用場景。

### 防止 effect 過於頻繁地觸發

如果不是作為 prop 傳遞給記憶化的元件，我們記憶化的值很可能最終會被傳遞給 effect 的依賴項（有時會經過多層自定義 hook）。

Effect 的依賴項遵循與 `React.memo` 相同的規則——它們使用 [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 逐一比較，以查看 effect 是否需要重新執行。所以如果我們不小心處理 effect 依賴項的記憶化，它可能會在每次渲染時都執行。

---

現在，如果我們仔細想想，可能會注意到這兩種情況實際上是完全相同的。它們都試圖通過快取來保持**相同的引用**，以避免某些事情發生。所以使用 `useCallback` 或 `useMemo` 的共同原因就是：

> **我需要引用穩定性。**

我認為我們都可以在生活中使用一些穩定性，那麼在什麼情況下追求穩定性是毫無意義的呢？

## 1. 沒有 memo - 沒有效能提升

讓我們拿上面的例子，做一個小小的改變：

```tsx title=no-memo
function Okay() {
  const value = useMemo(() => ({ hello: 'world' }), [])
  const onChange = useCallback((result) => console.log(result), [])

  return <Component value={value} onChange={onChange} />
}
```

你能發現差異嗎？沒錯——我們不再將 `value` 和 `onChange` 傳遞給記憶化的元件了——現在它只是一個普通的 React 函式元件。我經常看到這種情況發生，當值最終被傳遞給 React 內建元件時：

```tsx title=react-built-ins
function MyButton() {
  const onClick = useCallback(
    (event) => console.log(event.currentTarget.value),
    []
  )

  return <button onClick={onClick} />
}
```

在這裡，記憶化 `onClick` _什麼都沒有達成_，因為 `button` 不在乎 `onClick` 是否引用穩定。

> **什麼都沒有達成？**
>
> 「什麼都沒有達成」說法稍微有點不對，因為這裡確實有一些事情在幕後發生。React 必須創建一個快取來保存 `onClick` 函式。它必須追蹤依賴項，並在每次渲染時比較它們。傳遞給 `useCallback` 的內聯函式也會在每次渲染時重新創建，只是如果返回快取版本，它會立即被丟棄。
>
> 所以，這在技術上確實會在內部產生一些額外開銷。但我不想過度關注這一點，因為這個「開銷」不是問題所在。

所以如果你的自定義元件沒有被記憶化，它應該也不在乎引用穩定性！

等等——但如果那個 `Component` 在內部使用這些 props 來進行 `useEffect`，或者創建進一步的記憶化值，然後傳遞給它自己子元件的記憶化元件呢？如果我現在移除這些記憶化，我可能會破壞某些東西！

這就引出了第二點：

## 2. 使用 props 作為依賴項

將你獲得的非原始 `props` 添加到內部依賴陣列中很少是正確的，因為這個元件無法控制這些 props 的引用穩定性。一個常見的例子是：

```tsx title=props-as-dependencies
function OhNo({ onChange }) {
  const handleChange = useCallback(
    (e: React.ChangeEvent) => {
      trackAnalytics('changeEvent', e)
      onChange?.(e)
    },
    [onChange]
  )

  return <SomeMemoizedComponent onChange={handleChange} />
}
```

這個 `useCallback` 很可能是無用的，或者充其量，它取決於使用者如何使用這個元件。很可能會有一個調用方只是調用一個內聯函式：

```tsx title=inline-function
<OhNo onChange={() => props.doSomething()} />
```

這是一個無辜的用法。它沒有任何問題。事實上，它很棒。它將想要做的事情與事件處理器放在一起。它避免了將東西提取到文件頂部，使用那種難看的 `handleChange` 命名。

開發者寫這段程式碼時，唯一能知道它會破壞某些記憶化的方式，就是深入元件內部查看 props 是如何被使用的。這太糟糕了。

其他修復方法包括「我們隨時都記憶化所有東西」的策略，或者有嚴格執行的命名慣例，如「mustBeMemoized」前綴用於需要引用穩定的 props。這些都不是很好的方案。

### 一個真實的例子

由於我現在在 [sentry 程式碼庫](https://github.com/getsentry/sentry) 工作，它是開源的，我有很多真實的用法可以連結。我發現的一個情況是我們的 [useHotkeys](https://github.com/getsentry/sentry/blob/94f19a20bd5680ddc86b3e139853c3d505182b43/static/app/utils/useHotkeys.tsx) 自定義 hook。重要的部分看起來像這樣：

```tsx title=useHotkeys
export function useHotkeys(hotkeys: Hotkey[]): {
  const onKeyDown = useCallback(() => ..., [hotkeys])

  useEffect(() => {
    document.addEventListener('keydown', onKeyDown)

    return () => {
      document.removeEventListener('keydown', onKeyDown)
    }
  }, [onKeyDown])
}
```

這個自定義 hook 接收一個 `hotkeys` 陣列作為輸入，然後創建一個記憶化的 `onKeyDown` 函式，並傳遞給 effect。這個函式顯然是為了防止 effect 過於頻繁地觸發而記憶化的，但 `hotkeys` 是一個陣列意味著使用者必須手動記憶化它們。

我開始尋找所有 `useHotkeys` 的使用情況，驚喜地發現[除了一個](https://github.com/getsentry/sentry/blob/a80e48ce659dea903e4d9594420cde019b33b757/static/app/views/issueDetails/streamline/hooks/useCopyIssueDetails.tsx#L161-L172)之外，所有的都記憶化了輸入。然而，這不是完整的故事，因為如果我們看得更深，事情仍然會崩解。讓我們以[這個用法](https://github.com/getsentry/sentry/blob/97130081986520a2035882249b5670189d859dda/static/app/components/events/eventTagsAndScreenshot/screenshot/modal.tsx#L86)為例：

```tsx title=paginateHotKeys
const paginateHotkeys = useMemo(() => {
  return [
    { match: 'right', callback: () => paginateItems(1) },
    { match: 'left', callback: () => paginateItems(-1) },
  ]
}, [paginateItems])

useHotkeys(paginateHotkeys)
```

`useHotKeys` 傳遞了 `paginateHotkeys`，它是記憶化的，但它依賴於 `paginateItems`。那是從哪裡來的？嗯，它是另一個 `useCallback`，它[依賴於](https://github.com/getsentry/sentry/blob/97130081986520a2035882249b5670189d859dda/static/app/components/events/eventTagsAndScreenshot/screenshot/modal.tsx#L77) `screenshots` 和 `currentAttachmentIndex`。那 `screenshots` 是從哪裡來的？

```tsx title=breaking-memoization
const screenshots = attachments.filter(({ name }) =>
  name.includes('screenshot')
)
```

它是一個沒有記憶化的 `attachments.filter` 函式，它總是會創建一個新陣列，這會破壞所有下游的記憶化。這樣一來，它們都變得無用了。`paginateItems`、`paginateHotkeys`、`onKeyDown`。三個記憶化保證在每次渲染時重新執行，就像我們根本沒有寫它們一樣！

---

我希望這個例子能說明為什麼我強烈反對應用記憶化。根據我的經驗，它太容易失效了。不值得。而且它給我們必須閱讀的所有程式碼增加了太多開銷和複雜性。

這裡的修復方法不是也記憶化 `screenshots`。那只會把責任轉移到 `attachments`，而它是元件的一個 prop。在所有三個調用方，我們距離實際需要記憶化的地方（`useHotkeys`）至少有兩層。這變成了一場導航噩夢，最終，沒有人敢移除單個記憶化，因為我們無法知道它實際上在做什麼。

如果有什麼的話，我們必須把所有這些外包給[編譯器](https://react.dev/learn/react-compiler)，一旦我們讓它在所有地方都能工作，那就太棒了。但在那之前，我們必須找到模式來繞過需要引用穩定性的限制：

### Latest Ref 模式

我之前[寫過這個模式](refs-events-and-escape-hatches#the-latest-ref)；我們做的基本上是將我們想要在 effect 中獲得命令式存取的值存儲在一個 ref 中，然後用另一個故意在每次渲染時都執行的 effect 來更新這個值：

```tsx title=the-latest-ref {2-6}
export function useHotkeys(hotkeys: Hotkey[]): {
  const hotkeysRef = useRef(hotkeys)

  useEffect(() => {
    hotkeysRef.current = hotkeys
  })

  const onKeyDown = useCallback(() => ..., [])

  useEffect(() => {
    document.addEventListener('keydown', onKeyDown)

    return () => {
      document.removeEventListener('keydown', onKeyDown)
    }
  }, [])
}
```

然後，我們可以在 effect 中使用 `hotkeysRef`，而不必將它添加到依賴陣列中，也不必擔心如果我們只是忽略 linter 可能會遇到的[過時閉包](hooks-dependencies-and-stale-closures)問題。

React Query 也使用這個模式來追蹤傳入的最新選項，例如在 [PersistQueryClientProvider](https://github.com/TanStack/query/blob/dfbda9de66230e67b7e1c2f07e24eb5859ea14cb/packages/react-query-persist-client/src/PersistQueryClientProvider.tsx#L29-L31) 或 [useMutationState](https://github.com/TanStack/query/blob/34eedd601c7b19ac6a9fb8ab9c1ec0b600c2b95f/packages/react-query/src/useMutationState.ts#L53-L55) 中，所以我認為這是一個經過驗證的模式。想像一下如果這個函式庫需要使用者手動記憶化他們的 `options`...

### UseEffectEvent

還有更多好消息：React 已經意識到，我們經常需要在響應式 effect 中命令式地存取某些東西的最新值，而不需要明確地重新觸發它，所以他們將為這個用例添加這個模式作為一等原語，[useEffectEvent](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event)。

一旦它發布，我們可以將程式碼重構為：

```tsx title=the-latest-ref {2}
export function useHotkeys(hotkeys: Hotkey[]): {
  const onKeyDown = useEffectEvent(() => ...)

  useEffect(() => {
    document.addEventListener('keydown', onKeyDown)

    return () => {
      document.removeEventListener('keydown', onKeyDown)
    }
  }, [])
}
```

這會使 `onKeyDown` _不是_ 響應式的，它能夠始終「看到」`hotkeys` 的最新值，而且它在渲染之間是引用穩定的。這是所有世界中最好的結果，而不需要寫一個無用的 `useCallback` 或 `useMemo`。

---

今天就到這裡。如果你有任何問題，歡迎在 [bluesky](https://bsky.app/profile/tkdodo.eu) 上聯繫我，或者在下面留言。
